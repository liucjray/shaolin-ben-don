package main

import (
	"context"
	"database/sql"
	"log"
	"os"
	"time"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/jmoiron/sqlx"
	"github.com/pkg/errors"
	"github.com/wolftotem4/shaolin-ben-don/internal/action"
	"github.com/wolftotem4/shaolin-ben-don/internal/app"
	"github.com/wolftotem4/shaolin-ben-don/internal/conducts"
	database "github.com/wolftotem4/shaolin-ben-don/internal/db"
	"github.com/wolftotem4/shaolin-ben-don/internal/transformers"
	typesjson "github.com/wolftotem4/shaolin-ben-don/internal/types/json"
)

type Subscription map[int64]bool

var (
	subscribe   = make(chan int64)
	unsubscribe = make(chan int64)
	updateCmd   = make(chan bool)
)

func main() {
	ctx := context.Background()

	app, err := app.Register()
	if err != nil {
		log.Fatal(err)
	}

	if err := boot(ctx, app); err != nil {
		log.Fatal(err)
	}

	go func() {
		var (
			subscription Subscription

			// A value generated by session on webpage.
			// Some APIs needs the interface value to work.
			interfaceValue = 0

			// How often to call heartbeat to prevent session from expiring
			heartbeat = time.Tick(3 * time.Minute)

			// How often to trigger update
			updateInterval = time.Tick(10 * time.Minute)

			// record item IDs in order to avoid duplicate reports
			reported = ReportedItems{make(map[string]bool)}
		)

		log.Printf("Restoring subscriptions...")
		subscription, err = restoreSubscriptions(ctx, app.DB)
		if err != nil {
			log.Fatal(err)
		}
		log.Printf("Subscriptions restored.")

		updateFunc := func() {
			if len(subscription) == 0 {
				return
			}

			info := fetchItems(ctx, app, &interfaceValue)

			if info.NotEmpty() {
				reports := reported.extractUnreported(info.Items)
				broadcast(subscription, reports, app)
				reported.markReported(info.Items)
			}
		}

		for {
			select {
			case chatId := <-subscribe:
				subscription[chatId] = true

				handler := database.Handler{DB: app.DB}
				if err := handler.AddSubscription(ctx, chatId); err != nil {
					log.Fatal(err)
				}

				log.Printf("Chat [%d] subscribed.", chatId)
			case chatId := <-unsubscribe:
				delete(subscription, chatId)

				handler := database.Handler{DB: app.DB}
				if err := handler.DeleteSubscription(ctx, chatId); err != nil {
					log.Fatal(err)
				}

				log.Printf("Chat [%d] unsubscribed.", chatId)
			case <-updateCmd:
				updateFunc()
			case <-updateInterval:
				updateFunc()

				// save cookies to database
				if err := app.RealClient.Store.Save(ctx); err != nil {
					log.Fatal(err)
				}
			case <-heartbeat:
				// call heartbeat to prevent session from expiring
				act := action.HeartbeatAction{Client: app.Client}

				log.Println("Calling heartbeat...")
				if err != act.Call(ctx, interfaceValue) {
					log.Fatal(err)
				}
				log.Println("Heartbeat called.")
			}
		}
	}()

	log.Printf("Authorized on account %s", app.Bot.Self.UserName)

	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60

	updates := app.Bot.GetUpdatesChan(u)

	for update := range updates {
		if update.MyChatMember != nil && update.MyChatMember.NewChatMember.User.ID == app.Bot.Self.ID && update.MyChatMember.NewChatMember.HasLeft() {
			unsubscribe <- update.Message.Chat.ID
		}

		if update.Message != nil {
			// log.Printf("[%s] %s", update.Message.From.UserName, update.Message.Text)

			switch update.Message.Text {
			case "/subscribe":
				subscribe <- update.Message.Chat.ID

				msg := tgbotapi.NewMessage(update.Message.Chat.ID, "已訂閱")
				app.Bot.Send(msg)
			case "/unsubscribe":
				unsubscribe <- update.Message.Chat.ID

				msg := tgbotapi.NewMessage(update.Message.Chat.ID, "已取消訂閱")
				app.Bot.Send(msg)
			case "/update":
				updateCmd <- true

				msg := tgbotapi.NewMessage(update.Message.Chat.ID, "立即抓取最新資料.")
				app.Bot.Send(msg)
			}
		}
	}
}

func broadcast(subscription Subscription, items []*typesjson.ProgressItem, app *app.App) {
	log.Println("Broadcasting...")
	for chatId := range subscription {
		t := transformers.LinkItems{Items: items, Client: app.Client}

		msg := tgbotapi.NewMessage(chatId, t.String())
		app.Bot.Send(msg)
	}
	log.Println("Broadcasted.")
}

func fetchItems(ctx context.Context, app *app.App, interfaceValue *int) *conducts.FetchItemInfo {
	log.Println("Fetching Items...")
	info, err := conducts.GetUnexpiredItems(ctx, app, *interfaceValue)
	if err != nil {
		log.Fatal(err)
	}
	*interfaceValue = info.Interface
	log.Println("Items fetched.")
	return info
}

func boot(ctx context.Context, app *app.App) error {
	if err := createTable(ctx, app.DB.DB); err != nil {
		return errors.WithStack(err)
	}

	if err := app.RealClient.Load(ctx); err != nil {
		return errors.WithStack(err)
	}

	return nil
}

func createTable(ctx context.Context, db *sql.DB) error {
	ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
	defer cancel()

	s, err := os.ReadFile("data/create_tables.sql")
	if err != nil {
		return errors.WithStack(err)
	}

	_, err = db.ExecContext(ctx, string(s))
	if err != nil {
		return errors.WithStack(err)
	}

	return nil
}

type ReportedItems struct {
	Items map[string]bool
}

func (reported *ReportedItems) extractUnreported(items []*typesjson.ProgressItem) []*typesjson.ProgressItem {
	var reports []*typesjson.ProgressItem
	for _, item := range items {
		if !reported.Items[item.OrderHashId] {
			reports = append(reports, item)
		}
	}
	return reports
}

func (reported *ReportedItems) markReported(items []*typesjson.ProgressItem) {
	var result = make(map[string]bool)
	for _, item := range items {
		result[item.OrderHashId] = true
	}
	reported.Items = result
}

func restoreSubscriptions(ctx context.Context, db *sqlx.DB) (Subscription, error) {
	handler := database.Handler{DB: db}
	keys, err := handler.GetSubscriptions(ctx)
	if err != nil {
		return Subscription{}, errors.WithStack(err)
	}

	subscription := make(Subscription)
	for _, key := range keys {
		subscription[key] = true
	}

	return subscription, nil
}
